<?php

namespace App\Services;

use App\Models\Product;
use App\Models\InventoryMovement;
use App\Services\LLMService;
use App\Services\VectorSearchService;
use App\Services\VectorEmbeddingService;
use App\Services\DataService;
use Illuminate\Support\Facades\Log;

class InventoryAgent
{
    private LLMService $llmService;
    private VectorSearchService $vectorSearchService;
    private VectorEmbeddingService $vectorEmbeddingService;
    private DataService $dataService;

    public function __construct(LLMService $llmService, VectorSearchService $vectorSearchService, VectorEmbeddingService $vectorEmbeddingService, DataService $dataService)
    {
        $this->llmService = $llmService;
        $this->vectorSearchService = $vectorSearchService;
        $this->vectorEmbeddingService = $vectorEmbeddingService;
        $this->dataService = $dataService;
    }

    /**
     * Process inventory-related queries
     */
    public function process(string $message, array $context = []): array
    {
        Log::info('InventoryAgent: Processing message', ['message' => substr($message, 0, 100)]);

        try {
            // Low stock check
            if ($this->looksLikeLowStock($message)) {
                $threshold = $this->extractThreshold($message) ?? 5;
                return $this->handleLowStock($threshold);
            }

            // Product search
            if ($this->looksLikeProductSearch($message)) {
                return $this->handleProductSearch($message, $context);
            }

            // Inventory history
            if ($this->looksLikeInventoryHistory($message)) {
                return $this->handleInventoryHistory($message, $context);
            }

            // Stock adjustment
            if ($this->looksLikeStockAdjustment($message)) {
                return $this->handleStockAdjustment($message, $context);
            }

            // Fallback to LLM with inventory context
            return $this->handleGeneralInventoryQuery($message, $context);

        } catch (\Throwable $e) {
            Log::error('InventoryAgent: Error processing message', ['error' => $e->getMessage()]);
            return [
                'success' => false,
                'type' => 'error',
                'reply' => 'Xin l·ªói, Inventory Agent g·∫∑p l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.',
                'error' => $e->getMessage(),
                'products' => []
            ];
        }
    }

    /**
     * Check if message looks like low stock query
     */
    private function looksLikeLowStock(string $message): bool
    {
        return preg_match('/(t·ªìn|stock)\s*(th·∫•p|low|h·∫øt)/ui', $message) ||
               preg_match('/(ki·ªÉm tra|check)\s*(t·ªìn|stock)/ui', $message);
    }

    /**
     * Extract threshold from message
     */
    private function extractThreshold(string $message): ?int
    {
        if (preg_match('/(t·ªìn|stock)\s*(th·∫•p|low)\s*[<‚â§]\s*(\d+)/ui', $message, $matches)) {
            return (int) $matches[3];
        }
        return null;
    }

    /**
     * Handle low stock check
     */
    private function handleLowStock(int $threshold): array
    {
        $lowStockProducts = Product::where('is_active', true)
            ->where('stock', '<=', $threshold)
            ->get()
            ->map(function ($product) {
                return [
                    'id' => $product->id,
                    'name' => $product->name,
                    'total_stock' => $product->stock,
                    'low_stock_threshold' => $product->low_stock_threshold
                ];
            })
            ->values()
            ->toArray();

        if (empty($lowStockProducts)) {
            return [
                'success' => true,
                'type' => 'low_stock',
                'products' => [],
                'threshold' => $threshold,
                'reply' => "Kh√¥ng c√≥ s·∫£n ph·∫©m n√†o c√≥ t·ªìn ‚â§ {$threshold}."
            ];
        }

        $productNames = array_column($lowStockProducts, 'name');
        $reply = "‚ö†Ô∏è **C·∫¢NH B√ÅO T·ªíN KHO TH·∫§P**\n\n" .
                 "üîç **Ng∆∞·ª°ng c·∫£nh b√°o:** ‚â§ {$threshold} s·∫£n ph·∫©m\n" .
                 "üìä **T·ªïng s·ªë s·∫£n ph·∫©m:** " . count($lowStockProducts) . " s·∫£n ph·∫©m\n\n" .
                 "üì¶ **DANH S√ÅCH S·∫¢N PH·∫®M C·∫¶N NH·∫¨P H√ÄNG:**\n" .
                 $this->formatLowStockProducts($lowStockProducts) . "\n" .
                 "üí° **H√ÄNH ƒê·ªòNG KHUY·∫æN NGH·ªä:**\n" .
                 $this->getLowStockRecommendations(count($lowStockProducts));

        return [
            'success' => true,
            'type' => 'low_stock',
            'products' => $lowStockProducts,
            'threshold' => $threshold,
            'reply' => $reply
        ];
    }

    /**
     * Check if message looks like product search
     */
    private function looksLikeProductSearch(string $message): bool
    {
        return preg_match('/(t√¨m|search|g·ª£i √Ω)\s*(s·∫£n ph·∫©m|product|n∆∞·ªõc hoa)/ui', $message) ||
               preg_match('/(n∆∞·ªõc hoa|perfume)\s*(nam|n·ªØ|men|women)/ui', $message);
    }

    /**
     * Handle product search with vector search
     */
    private function handleProductSearch(string $message, array $context): array
    {
        try {
            // Use vector search for semantic product search
            $searchResults = $this->vectorEmbeddingService->searchProducts($message, 5);
            
            if (empty($searchResults)) {
                return [
                    'success' => true,
                    'type' => 'product_search',
                    'products' => [],
                    'reply' => 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p v·ªõi y√™u c·∫ßu c·ªßa b·∫°n.'
                ];
            }

            $products = collect($searchResults)->map(function ($result) {
                $data = $result['data'];
                $metadata = $data['metadata'] ?? [];
                return [
                    'id' => $data['embeddable_id'],
                    'name' => $metadata['brand'] . ' ' . $data['content_text'],
                    'price' => number_format($metadata['price'] ?? 0),
                    'category' => $metadata['category'] ?? '',
                    'similarity' => round($result['final_score'] * 100, 1)
                ];
            })->toArray();

            $productNames = array_column($products, 'name');
            $reply = "üîç **K·∫æT QU·∫¢ T√åM KI·∫æM S·∫¢N PH·∫®M**\n\n" .
                     "üìä **T√¨m th·∫•y:** " . count($products) . " s·∫£n ph·∫©m ph√π h·ª£p\n\n" .
                     "üõçÔ∏è **DANH S√ÅCH S·∫¢N PH·∫®M:**\n" .
                     $this->formatProductSearchResults($products) . "\n" .
                     "üí° **G·ª¢I √ù:** " . $this->getProductSearchSuggestions($products);

            return [
                'success' => true,
                'type' => 'product_search',
                'products' => $products,
                'reply' => $reply
            ];

        } catch (\Throwable $e) {
            Log::warning('InventoryAgent: Vector search failed, falling back to text search', ['error' => $e->getMessage()]);
            
            // Fallback to text search
            $products = Product::where('name', 'LIKE', "%{$message}%")
                ->orWhere('description', 'LIKE', "%{$message}%")
                ->limit(5)
                ->get()
                ->map(function ($product) {
                    return [
                        'id' => $product->id,
                        'name' => $product->name,
                        'price' => number_format($product->price),
                        'category' => $product->category->name ?? 'N/A',
                        'similarity' => 0
                    ];
                })
                ->toArray();

            if (empty($products)) {
                return [
                    'success' => true,
                    'type' => 'product_search',
                    'products' => [],
                    'reply' => 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p v·ªõi y√™u c·∫ßu c·ªßa b·∫°n.'
                ];
            }

            $productNames = array_column($products, 'name');
            $reply = "T√¨m th·∫•y " . count($products) . " s·∫£n ph·∫©m: " . implode(', ', $productNames);

            return [
                'success' => true,
                'type' => 'product_search',
                'products' => $products,
                'reply' => $reply
            ];
        }
    }

    /**
     * Check if message looks like inventory history query
     */
    private function looksLikeInventoryHistory(string $message): bool
    {
        return preg_match('/(l·ªãch s·ª≠|history)\s*(t·ªìn|inventory|kho)/ui', $message) ||
               preg_match('/(xu·∫•t|nh·∫≠p)\s*(kho|inventory)/ui', $message);
    }

    /**
     * Handle inventory history
     */
    private function handleInventoryHistory(string $message, array $context): array
    {
        $movements = InventoryMovement::with(['product', 'user'])
            ->orderBy('created_at', 'desc')
            ->limit(10)
            ->get()
            ->map(function ($movement) {
                return [
                    'id' => $movement->id,
                    'product_name' => $movement->product->name ?? 'Unknown',
                    'type' => $movement->type,
                    'quantity' => $movement->quantity,
                    'reason' => $movement->reason,
                    'user_name' => $movement->user->name ?? 'System',
                    'created_at' => $movement->created_at->format('d/m/Y H:i')
                ];
            })
            ->toArray();

        if (empty($movements)) {
            return [
                'success' => true,
                'type' => 'inventory_history',
                'movements' => [],
                'reply' => 'Ch∆∞a c√≥ l·ªãch s·ª≠ t·ªìn kho n√†o.',
                'products' => []
            ];
        }

        $movementTexts = array_map(function ($movement) {
            $type = $movement['type'] ?? 'Unknown';
            $quantity = $movement['quantity'] ?? 0;
            $productName = $movement['product_name'] ?? 'Unknown';
            $reason = $movement['reason'] ?? 'N/A';
            return "{$type} {$quantity} {$productName} - {$reason}";
        }, $movements);

        $reply = "L·ªãch s·ª≠ t·ªìn kho g·∫ßn nh·∫•t:\n" . implode("\n", $movementTexts);

        return [
            'success' => true,
            'type' => 'inventory_history',
            'movements' => $movements,
            'reply' => $reply,
            'products' => []
        ];
    }

    /**
     * Check if message looks like stock adjustment
     */
    private function looksLikeStockAdjustment(string $message): bool
    {
        return preg_match('/(ƒëi·ªÅu ch·ªânh|adjust|thay ƒë·ªïi)\s*(t·ªìn|stock)/ui', $message) ||
               preg_match('/(c·∫≠p nh·∫≠t|update)\s*(s·ªë l∆∞·ª£ng|quantity)/ui', $message);
    }

    /**
     * Handle stock adjustment (proposal for human approval)
     */
    private function handleStockAdjustment(string $message, array $context): array
    {
        // This would typically require human approval
        return [
            'success' => true,
            'type' => 'stock_adjustment_proposal',
            'needs_approval' => true,
            'proposal' => [
                'type' => 'stock_adjustment',
                'message' => 'ƒê·ªÅ xu·∫•t ƒëi·ªÅu ch·ªânh t·ªìn kho',
                'details' => 'C·∫ßn ph√™ duy·ªát tr∆∞·ªõc khi th·ª±c hi·ªán ƒëi·ªÅu ch·ªânh t·ªìn kho'
            ],
            'reply' => 'T√¥i c√≥ th·ªÉ gi√∫p b·∫°n ƒëi·ªÅu ch·ªânh t·ªìn kho. Tuy nhi√™n, thao t√°c n√†y c·∫ßn ƒë∆∞·ª£c ph√™ duy·ªát tr∆∞·ªõc khi th·ª±c hi·ªán.',
            'products' => []
        ];
    }

    /**
     * Handle general inventory queries with enhanced business logic
     */
    private function handleGeneralInventoryQuery(string $message, array $context): array
    {
        // Get real product data first
        $businessContext = $this->dataService->getBusinessContext();
        $products = $businessContext['products']['products'] ?? [];
        
        if (empty($products)) {
            return [
                'success' => true,
                'type' => 'general',
                'reply' => 'üì¶ **B√ÅO C√ÅO T·ªíN KHO**\n\nKh√¥ng c√≥ d·ªØ li·ªáu s·∫£n ph·∫©m trong h·ªá th·ªëng. Vui l√≤ng th√™m s·∫£n ph·∫©m v√†o kho tr∆∞·ªõc khi ki·ªÉm tra.',
                'products' => []
            ];
        }
        
        // Generate real inventory report
        $reply = $this->generateRealInventoryReport($products);
        
        return [
            'success' => true,
            'type' => 'inventory_report',
            'reply' => $reply,
            'products' => $products
        ];
    }
    
    /**
     * Generate real inventory report based on actual data
     */
    private function generateRealInventoryReport(array $products): string
    {
        $lowStockProducts = [];
        $outOfStockProducts = [];
        $normalStockProducts = [];
        
        foreach ($products as $product) {
            $totalStock = $product['variants'] ? 
                array_sum(array_column($product['variants'], 'stock')) : 
                ($product['stock'] ?? 0);
            
            if ($totalStock == 0) {
                $outOfStockProducts[] = $product;
            } elseif ($totalStock <= 5) {
                $lowStockProducts[] = $product;
            } else {
                $normalStockProducts[] = $product;
            }
        }
        
        $report = "üì¶ **B√ÅO C√ÅO T·ªíN KHO TH·ª∞C T·∫æ**\n\n";
        
        // Summary
        $report .= "**T·ªîNG QUAN:**\n";
        $report .= "‚Ä¢ T·ªïng s·∫£n ph·∫©m: " . count($products) . " s·∫£n ph·∫©m\n";
        $report .= "‚Ä¢ H·∫øt h√†ng: " . count($outOfStockProducts) . " s·∫£n ph·∫©m\n";
        $report .= "‚Ä¢ T·ªìn th·∫•p (‚â§5): " . count($lowStockProducts) . " s·∫£n ph·∫©m\n";
        $report .= "‚Ä¢ T·ªìn ƒë·ªß (>5): " . count($normalStockProducts) . " s·∫£n ph·∫©m\n\n";
        
        // Out of stock products
        if (!empty($outOfStockProducts)) {
            $report .= "**1. S·∫¢N PH·∫®M H·∫æT H√ÄNG:**\n";
            foreach ($outOfStockProducts as $product) {
                $report .= "‚Ä¢ " . $product['name'] . " (" . ($product['brand'] ?? 'N/A') . ")\n";
            }
            $report .= "\n";
        }
        
        // Low stock products
        if (!empty($lowStockProducts)) {
            $report .= "**2. S·∫¢N PH·∫®M T·ªíN TH·∫§P:**\n";
            foreach ($lowStockProducts as $product) {
                $totalStock = $product['variants'] ? 
                    array_sum(array_column($product['variants'], 'stock')) : 
                    ($product['stock'] ?? 0);
                $report .= "‚Ä¢ " . $product['name'] . " - T·ªìn: " . $totalStock . " (" . ($product['brand'] ?? 'N/A') . ")\n";
            }
            $report .= "\n";
        }
        
        // Normal stock products
        if (!empty($normalStockProducts)) {
            $report .= "**3. S·∫¢N PH·∫®M T·ªíN ƒê·ª¶:**\n";
            foreach ($normalStockProducts as $product) {
                $totalStock = $product['variants'] ? 
                    array_sum(array_column($product['variants'], 'stock')) : 
                    ($product['stock'] ?? 0);
                $report .= "‚Ä¢ " . $product['name'] . " - T·ªìn: " . $totalStock . " (" . ($product['brand'] ?? 'N/A') . ")\n";
            }
            $report .= "\n";
        }
        
        // Recommendations
        $report .= "**4. KHUY·∫æN NGH·ªä:**\n";
        if (!empty($outOfStockProducts)) {
            $report .= "‚Ä¢ ƒê·∫∑t h√†ng ngay cho " . count($outOfStockProducts) . " s·∫£n ph·∫©m h·∫øt h√†ng\n";
        }
        if (!empty($lowStockProducts)) {
            $report .= "‚Ä¢ Xem x√©t nh·∫≠p th√™m cho " . count($lowStockProducts) . " s·∫£n ph·∫©m t·ªìn th·∫•p\n";
        }
        if (empty($outOfStockProducts) && empty($lowStockProducts)) {
            $report .= "‚Ä¢ T√¨nh tr·∫°ng t·ªìn kho ·ªïn ƒë·ªãnh\n";
        }
        
        $report .= "\nN·∫øu c·∫ßn th√¥ng tin chi ti·∫øt v·ªÅ s·∫£n ph·∫©m c·ª• th·ªÉ, h√£y cho t√¥i bi·∫øt! üìä";
        
        return $report;
    }

    /**
     * Format product search results professionally
     */
    private function formatProductSearchResults(array $products): string
    {
        $formatted = '';
        foreach ($products as $index => $product) {
            $rank = $index + 1;
            $similarity = $product['similarity'] ?? 0;
            $similarityIcon = $similarity >= 80 ? 'üü¢' : ($similarity >= 60 ? 'üü°' : 'üî¥');
            
            $name = $product['name'] ?? 'Unknown';
            $price = $product['price'] ?? 'N/A';
            $category = $product['category'] ?? 'N/A';
            
            $formatted .= "{$rank}. **{$name}**\n";
            $formatted .= "   üí∞ Gi√°: {$price}ƒë\n";
            $formatted .= "   üìÇ Danh m·ª•c: {$category}\n";
            $formatted .= "   üéØ ƒê·ªô ph√π h·ª£p: {$similarityIcon} {$similarity}%\n\n";
        }
        
        return $formatted;
    }

    /**
     * Get product search suggestions
     */
    private function getProductSearchSuggestions(array $products): string
    {
        if (empty($products)) {
            return "Th·ª≠ t√¨m ki·∫øm v·ªõi t·ª´ kh√≥a kh√°c ho·∫∑c m√¥ t·∫£ chi ti·∫øt h∆°n";
        }
        
        $highSimilarityCount = count(array_filter($products, fn($p) => ($p['similarity'] ?? 0) >= 80));
        
        if ($highSimilarityCount > 0) {
            return "C√≥ s·∫£n ph·∫©m ph√π h·ª£p cao, c√≥ th·ªÉ xem chi ti·∫øt ho·∫∑c so s√°nh";
        } else {
            return "C√≥ th·ªÉ c·∫ßn m√¥ t·∫£ chi ti·∫øt h∆°n v·ªÅ m√πi h∆∞∆°ng ho·∫∑c ƒë·∫∑c ƒëi·ªÉm mong mu·ªën";
        }
    }

    /**
     * Format low stock products professionally
     */
    private function formatLowStockProducts(array $products): string
    {
        $formatted = '';
        foreach ($products as $index => $product) {
            $rank = $index + 1;
            $totalStock = $product['total_stock'] ?? 0;
            $urgency = $totalStock == 0 ? 'üî¥ H·∫æT H√ÄNG' : 
                      ($totalStock <= 2 ? 'üü† C·∫§P B√ÅCH' : 'üü° C·∫¢NH B√ÅO');
            
            $name = $product['name'] ?? 'Unknown';
            $formatted .= "{$rank}. **{$name}** - {$totalStock} s·∫£n ph·∫©m ({$urgency})\n";
        }
        
        return $formatted;
    }

    /**
     * Get low stock recommendations
     */
    private function getLowStockRecommendations(int $productCount): string
    {
        if ($productCount == 0) {
            return "‚Ä¢ T√¨nh h√¨nh t·ªìn kho ·ªïn ƒë·ªãnh, ti·∫øp t·ª•c theo d√µi";
        } elseif ($productCount <= 3) {
            return "‚Ä¢ ∆Øu ti√™n nh·∫≠p h√†ng cho c√°c s·∫£n ph·∫©m h·∫øt h√†ng\n‚Ä¢ Li√™n h·ªá nh√† cung c·∫•p ƒë·ªÉ ƒë·∫∑t h√†ng\n‚Ä¢ C·∫≠p nh·∫≠t tr·∫°ng th√°i s·∫£n ph·∫©m tr√™n website";
        } else {
            return "‚Ä¢ C·∫ßn c√≥ k·∫ø ho·∫°ch nh·∫≠p h√†ng t·ªïng th·ªÉ\n‚Ä¢ Ph√¢n t√≠ch xu h∆∞·ªõng ti√™u th·ª• ƒë·ªÉ d·ª± b√°o nhu c·∫ßu\n‚Ä¢ Xem x√©t ƒëi·ªÅu ch·ªânh gi√° ƒë·ªÉ c√¢n b·∫±ng cung c·∫ßu";
        }
    }

    /**
     * Get current inventory context for LLM
     */
    private function getInventoryContext(): string
    {
        try {
            $lowStockProducts = Product::with(['variants'])
                ->get()
                ->filter(function ($product) {
                    return $product->variants->sum('stock_quantity') <= 5;
                })
                ->count();
            
            $totalProducts = Product::count();
            $outOfStockProducts = Product::with(['variants'])
                ->get()
                ->filter(function ($product) {
                    return $product->variants->sum('stock_quantity') == 0;
                })
                ->count();
            
            return "T·ªïng s·∫£n ph·∫©m: {$totalProducts}. T·ªìn th·∫•p (‚â§5): {$lowStockProducts}. H·∫øt h√†ng: {$outOfStockProducts}";
        } catch (\Throwable $e) {
            return "D·ªØ li·ªáu t·ªìn kho hi·ªán t·∫°i kh√¥ng kh·∫£ d·ª•ng";
        }
    }

    /**
     * Format products for inventory context
     */
    private function formatProductsForInventory(array $products): string
    {
        if (empty($products)) {
            return '';
        }

        $formatted = "üì¶ **DANH S√ÅCH S·∫¢N PH·∫®M HI·ªÜN T·∫†I:**\n\n";
        
        foreach ($products as $i => $product) {
            $formatted .= "**" . ((int)$i + 1) . ". " . $product['name'] . "**\n";
            $formatted .= "‚Ä¢ **Th∆∞∆°ng hi·ªáu:** " . ($product['brand'] ?? 'N/A') . "\n";
            $price = $product['price'] ?? 0;
            $formatted .= "‚Ä¢ **Gi√°:** " . (is_numeric($price) ? number_format((float)$price) : 'N/A') . "ƒë\n";
            $formatted .= "‚Ä¢ **T·ªìn kho:** " . (int)($product['stock'] ?? 0) . " s·∫£n ph·∫©m\n";
            $formatted .= "‚Ä¢ **Danh m·ª•c:** " . ($product['category'] ?? 'N/A') . "\n";
            $formatted .= "‚Ä¢ **Tr·∫°ng th√°i:** " . ($product['is_active'] ? 'Ho·∫°t ƒë·ªông' : 'Ng·ª´ng b√°n') . "\n";
            
            if (!empty($product['variants'])) {
                $formatted .= "‚Ä¢ **Bi·∫øn th·ªÉ:** " . count($product['variants']) . " lo·∫°i\n";
            }
            
            $formatted .= "\n";
        }

        return $formatted;
    }
}
