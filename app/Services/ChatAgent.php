<?php

namespace App\Services;

use App\Models\Product;
use App\Services\LLMService;
use App\Services\VectorSearchService;
use App\Services\VectorEmbeddingService;
use App\Services\DataService;
use Illuminate\Support\Facades\Log;

class ChatAgent
{
    private LLMService $llmService;
    private VectorSearchService $vectorSearchService;
    private VectorEmbeddingService $vectorEmbeddingService;
    private DataService $dataService;

    public function __construct(LLMService $llmService, VectorSearchService $vectorSearchService, VectorEmbeddingService $vectorEmbeddingService, DataService $dataService)
    {
        $this->llmService = $llmService;
        $this->vectorSearchService = $vectorSearchService;
        $this->vectorEmbeddingService = $vectorEmbeddingService;
        $this->dataService = $dataService;
    }

    /**
     * Process chat and semantic search queries
     */
    public function process(string $message, array $context = []): array
    {
        Log::info('ChatAgent: Processing message', ['message' => substr($message, 0, 100)]);

        try {
            // Product recommendation
            if ($this->looksLikeProductRecommendation($message)) {
                return $this->handleProductRecommendation($message, $context);
            }

            // Semantic search
            if ($this->looksLikeSemanticSearch($message)) {
                return $this->handleSemanticSearch($message, $context);
            }

            // General chat with enhanced context
            return $this->handleGeneralChat($message, $context);

        } catch (\Throwable $e) {
            Log::error('ChatAgent: Error processing message', ['error' => $e->getMessage()]);
            return [
                'success' => false,
                'type' => 'error',
                'reply' => 'Xin l·ªói, Chat Agent g·∫∑p l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.',
                'error' => $e->getMessage(),
                'products' => []
            ];
        }
    }

    /**
     * Check if message looks like product recommendation
     */
    private function looksLikeProductRecommendation(string $message): bool
    {
        return preg_match('/(g·ª£i √Ω|recommend|suggest)\s*(s·∫£n ph·∫©m|product|n∆∞·ªõc hoa)/ui', $message) ||
               preg_match('/(n∆∞·ªõc hoa|perfume)\s*(n√†o|g√¨|cho)/ui', $message) ||
               preg_match('/(t√¥i|m√¨nh)\s*(th√≠ch|mu·ªën|c·∫ßn)\s*(n∆∞·ªõc hoa|perfume)/ui', $message);
    }

    /**
     * Handle product recommendation with vector search
     */
    private function handleProductRecommendation(string $message, array $context): array
    {
        try {
            // Use vector store for semantic product recommendation
            $searchResults = $this->vectorEmbeddingService->searchProducts($message, 5);
            
            if (empty($searchResults)) {
                return [
                    'success' => true,
                    'type' => 'product_recommendation',
                    'products' => [],
                    'reply' => 'T√¥i ch∆∞a th·ªÉ t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p v·ªõi s·ªü th√≠ch c·ªßa b·∫°n. B·∫°n c√≥ th·ªÉ m√¥ t·∫£ c·ª• th·ªÉ h∆°n v·ªÅ m√πi h∆∞∆°ng ho·∫∑c phong c√°ch b·∫°n th√≠ch kh√¥ng?'
                ];
            }

            $products = collect($searchResults)->map(function ($result) {
                $data = $result['data'];
                $metadata = $data['metadata'] ?? [];
                return [
                    'id' => $data['embeddable_id'],
                    'name' => $metadata['brand'] . ' ' . $data['content_text'],
                    'price' => number_format($metadata['price'] ?? 0),
                    'category' => $metadata['category'] ?? '',
                    'description' => $data['content_text'],
                    'similarity' => round($result['final_score'] * 100, 1)
                ];
            })->toArray();

            // Use LLM to generate personalized recommendation
            if ($this->llmService->isConfigured()) {
                $systemPrompt = "B·∫°n l√† chuy√™n gia t∆∞ v·∫•n n∆∞·ªõc hoa. D·ª±a tr√™n danh s√°ch s·∫£n ph·∫©m v√† y√™u c·∫ßu c·ªßa kh√°ch h√†ng, h√£y ƒë∆∞a ra l·ªùi khuy√™n c√° nh√¢n h√≥a.";
                
                $productContext = json_encode($products, JSON_UNESCAPED_UNICODE);
                
                $recommendation = $this->llmService->chat($message, [
                    'system' => $systemPrompt,
                    'relevant_products' => $productContext
                ]);
            } else {
                $productNames = array_column($products, 'name');
                $recommendation = "D·ª±a tr√™n s·ªü th√≠ch c·ªßa b·∫°n, t√¥i g·ª£i √Ω c√°c s·∫£n ph·∫©m sau: " . implode(', ', $productNames);
            }

            return [
                'success' => true,
                'type' => 'product_recommendation',
                'products' => $products,
                'reply' => $recommendation
            ];

        } catch (\Throwable $e) {
            Log::warning('ChatAgent: Vector search failed for recommendation', ['error' => $e->getMessage()]);
            
            // Fallback to text-based recommendation
            return $this->handleTextBasedRecommendation($message, $context);
        }
    }

    /**
     * Check if message looks like semantic search
     */
    private function looksLikeSemanticSearch(string $message): bool
    {
        return preg_match('/(t√¨m|search|ki·∫øm)\s*(n∆∞·ªõc hoa|perfume|s·∫£n ph·∫©m)/ui', $message) ||
               preg_match('/(c√≥|n√†o)\s*(n∆∞·ªõc hoa|perfume)\s*(nam|n·ªØ|men|women)/ui', $message) ||
               preg_match('/(m√πi|h∆∞∆°ng|fragrance)\s*(n√†o|g√¨)/ui', $message) ||
               preg_match('/n∆∞·ªõc hoa\s*(nam|n·ªØ|men|women|quy·∫øn r≈©|th∆°m|ng·ªçt)/ui', $message) ||
               preg_match('/(perfume|n∆∞·ªõc hoa)\s*(cho|d√†nh cho|ph√π h·ª£p)/ui', $message);
    }

    /**
     * Handle semantic search
     */
    private function handleSemanticSearch(string $message, array $context): array
    {
        try {
            // Use vector search for semantic product search
            $searchResults = $this->vectorEmbeddingService->searchProducts($message, 8);
            
            // Get business context for LLM
            $businessContext = $this->dataService->getBusinessContext();
            $chatData = $this->dataService->getAgentSpecificContext('chat');
            
            // Format product data for LLM
            $productData = '';
            if (!empty($searchResults)) {
                $productData = "üõçÔ∏è **S·∫¢N PH·∫®M T√åM TH·∫§Y:**\n\n";
                foreach ($searchResults as $i => $result) {
                    $data = $result['data'];
                    $metadata = $data['metadata'] ?? [];
                    $productName = ($metadata['brand'] ?? '') . " " . $data['content_text'];
                    
                    $productData .= "**" . ((int)$i + 1) . ". " . $productName . "**\n";
                    $productData .= "‚Ä¢ **Gi√°:** " . number_format((float)($metadata['price'] ?? 0)) . "ƒë\n";
                    $productData .= "‚Ä¢ **Danh m·ª•c:** " . ($metadata['category'] ?? 'N/A') . "\n";
                    $productData .= "‚Ä¢ **T·ªìn kho:** " . ($metadata['stock'] ?? 0) . " s·∫£n ph·∫©m\n";
                    $productData .= "‚Ä¢ **ƒê·ªô t∆∞∆°ng ƒë·ªìng:** " . round($result['final_score'] * 100, 1) . "%\n\n";
                }
            } else {
                // Fallback to DataService
                   try {
                       if (isset($businessContext['products']['products']) && !empty($businessContext['products']['products'])) {
                           $allProducts = $businessContext['products']['products'];
                           $filteredProducts = $this->filterProductsByQuery($allProducts, $message);
                           if (!empty($filteredProducts)) {
                               $productData = "üõçÔ∏è **S·∫¢N PH·∫®M T√åM TH·∫§Y:**\n\n";
                               foreach (array_slice($filteredProducts, 0, 5) as $i => $product) {
                                   $productData .= "**" . ((int)$i + 1) . ". " . $product['name'] . "**\n";
                                   $productData .= "‚Ä¢ **Th∆∞∆°ng hi·ªáu:** " . ($product['brand'] ?? 'N/A') . "\n";
                                   $productData .= "‚Ä¢ **Gi√°:** " . number_format((float)($product['price'] ?? 0)) . "ƒë\n";
                                   $productData .= "‚Ä¢ **T·ªìn kho:** " . ($product['stock'] ?? 0) . " s·∫£n ph·∫©m\n\n";
                               }
                           }
                       }
                   } catch (\Throwable $e) {
                       Log::warning('ChatAgent: DataService fallback failed', ['error' => $e->getMessage()]);
                   }
            }

            if (!$this->llmService->isConfigured()) {
                if (!empty($searchResults)) {
                    $productNames = array_column(array_map(fn($r) => $r['data'], $searchResults), 'content_text');
                    $reply = "T√¨m th·∫•y " . count($searchResults) . " s·∫£n ph·∫©m: " . implode(', ', $productNames);
                } else {
                    $reply = 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o ph√π h·ª£p v·ªõi y√™u c·∫ßu c·ªßa b·∫°n.';
                }
                
                return [
                    'success' => true,
                    'type' => 'semantic_search',
                    'products' => $searchResults,
                    'reply' => $reply
                ];
            }

            $systemPrompt = "B·∫°n l√† Chat Agent chuy√™n nghi·ªáp trong c·ª≠a h√†ng n∆∞·ªõc hoa cao c·∫•p.

**VAI TR√í & TR√ÅCH NHI·ªÜM:**
- Chuy√™n gia t∆∞ v·∫•n n∆∞·ªõc hoa v√† m√πi h∆∞∆°ng
- Tr·ª£ l√Ω c·ª≠a h√†ng n∆∞·ªõc hoa chuy√™n nghi·ªáp
- Ng∆∞·ªùi b·∫°n am hi·ªÉu v·ªÅ th·∫ø gi·ªõi n∆∞·ªõc hoa

**KH·∫¢ NƒÇNG CHUY√äN M√îN:**
- T√¨m ki·∫øm s·∫£n ph·∫©m: \"n∆∞·ªõc hoa nam\", \"m√πi h∆∞∆°ng n·ªØ\", \"n∆∞·ªõc hoa sang tr·ªçng\"
- G·ª£i √Ω c√° nh√¢n: \"t√¥i th√≠ch m√πi g√¨\", \"ph√π h·ª£p v·ªõi ai\"
- T∆∞ v·∫•n m√πi h∆∞∆°ng: \"m√πi n√†o ph√π h·ª£p\", \"c√°ch ch·ªçn n∆∞·ªõc hoa\"
- Th√¥ng tin s·∫£n ph·∫©m: gi√°, xu·∫•t x·ª©, ƒë·∫∑c ƒëi·ªÉm

**QUAN TR·ªåNG - FORMAT S·∫¢N PH·∫®M:**
- KH√îNG s·ª≠ d·ª•ng ### trong ti√™u ƒë·ªÅ s·∫£n ph·∫©m
- S·ª≠ d·ª•ng **T√™n s·∫£n ph·∫©m** thay v√¨ ### T√™n s·∫£n ph·∫©m
- KH√îNG s·ª≠ d·ª•ng ### 1. ### 2. ### 3. - ch·ªâ d√πng **1.** **2.** **3.**
- N·∫øu c√≥ d·ªØ li·ªáu s·∫£n ph·∫©m trong product_data, H√ÉY S·ª¨ D·ª§NG CH√çNH X√ÅC
- KH√îNG t·ª± t·∫°o danh s√°ch s·∫£n ph·∫©m - ch·ªâ s·ª≠ d·ª•ng d·ªØ li·ªáu c√≥ s·∫µn

**PHONG C√ÅCH TR·∫¢ L·ªúI:**
- Th√¢n thi·ªán, nhi·ªát t√¨nh, chuy√™n nghi·ªáp
- S·ª≠ d·ª•ng emoji ph√π h·ª£p (üí¨üå∏‚ú®üõçÔ∏è)
- ƒê∆∞a ra l·ªùi khuy√™n h·ªØu √≠ch v√† ch√≠nh x√°c
- Format d·ªØ li·ªáu d·ªÖ ƒë·ªçc v·ªõi markdown
- Lu√¥n d·ª±a tr√™n d·ªØ li·ªáu th·ª±c t·∫ø t·ª´ h·ªá th·ªëng

**D·ªÆ LI·ªÜU S·∫¢N PH·∫®M:**
{$productData}";

            $reply = $this->llmService->chat($message, [
                'system' => $systemPrompt,
                'conversation_history' => $context['conversation_history'] ?? [],
                'real_data' => $this->dataService->formatBusinessContextForLLM($businessContext),
                'agent_data' => $chatData,
                'product_data' => $productData
            ]);
            
            // Remove ### from reply if present
            $reply = preg_replace('/###\s*\d+\.\s*/', '', $reply);
            $reply = str_replace('###', '', $reply); // Fallback

            return [
                'success' => true,
                'type' => 'semantic_search',
                'products' => $searchResults,
                'reply' => $reply
            ];

        } catch (\Throwable $e) {
            Log::warning('ChatAgent: Vector search failed for semantic search', ['error' => $e->getMessage()]);
            
            // Fallback to text-based search
            return $this->handleTextBasedSearch($message, $context);
        }
    }

    /**
     * Handle general chat with enhanced context and business logic
     */
    private function handleGeneralChat(string $message, array $context): array
    {
        if (!$this->llmService->isConfigured()) {
            return [
                'success' => true,
                'type' => 'general',
                'reply' => 'üí¨ Chat Agent: T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n‚Ä¢ T√¨m ki·∫øm s·∫£n ph·∫©m th√¥ng minh\n‚Ä¢ G·ª£i √Ω n∆∞·ªõc hoa ph√π h·ª£p\n‚Ä¢ T∆∞ v·∫•n v·ªÅ m√πi h∆∞∆°ng\n‚Ä¢ Tr√≤ chuy·ªán v·ªÅ n∆∞·ªõc hoa\n‚Ä¢ H·ªó tr·ª£ c√°c c√¢u h·ªèi chung\n\nH√£y h·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨!',
                'products' => []
            ];
        }

        // Try to find relevant products for context
        $relevantProducts = '';
        $productData = [];
        
        if ($this->looksLikeProductQuery($message)) {
            try {
                // First try vector search
                $vectorProducts = $this->vectorEmbeddingService->searchProducts($message, 3);
                if (!empty($vectorProducts)) {
                    $relevantProducts = $this->formatProductsForLLM($vectorProducts);
                    $productData = $vectorProducts;
                    Log::info('ChatAgent: Found relevant products via vector search', ['count' => count($vectorProducts)]);
                } else {
                    // Fallback to DataService
                    $businessContext = $this->dataService->getBusinessContext();
                    if (isset($businessContext['products']) && !empty($businessContext['products'])) {
                        $allProducts = $businessContext['products'];
                        $filteredProducts = $this->filterProductsByQuery($allProducts, $message);
                        if (!empty($filteredProducts)) {
                            $relevantProducts = $this->formatProductsFromDataService($filteredProducts);
                            $productData = $filteredProducts;
                            Log::info('ChatAgent: Found relevant products via DataService', ['count' => count($filteredProducts)]);
                        }
                    }
                }
            } catch (\Throwable $e) {
                Log::warning('ChatAgent: Failed to get product context', ['error' => $e->getMessage()]);
            }
        }

        // Get enhanced chat context from DataService
        $chatData = $this->dataService->getAgentSpecificContext('chat');

        $systemPrompt = "B·∫°n l√† Chat Agent - tr·ª£ l√Ω th√¥ng minh v√† chuy√™n nghi·ªáp chuy√™n v·ªÅ n∆∞·ªõc hoa cao c·∫•p.

        **VAI TR√í & TR√ÅCH NHI·ªÜM:**
        - Chuy√™n gia t∆∞ v·∫•n n∆∞·ªõc hoa v√† m√πi h∆∞∆°ng
        - Tr·ª£ l√Ω c·ª≠a h√†ng n∆∞·ªõc hoa chuy√™n nghi·ªáp
        - Ng∆∞·ªùi b·∫°n am hi·ªÉu v·ªÅ th·∫ø gi·ªõi n∆∞·ªõc hoa
        
        **KH·∫¢ NƒÇNG CHUY√äN M√îN:**
        - T√¨m ki·∫øm s·∫£n ph·∫©m: \"n∆∞·ªõc hoa nam\", \"m√πi h∆∞∆°ng n·ªØ\"
        - G·ª£i √Ω c√° nh√¢n: \"t√¥i th√≠ch m√πi g√¨\", \"ph√π h·ª£p v·ªõi ai\"
        - T∆∞ v·∫•n m√πi h∆∞∆°ng: \"m√πi n√†o ph√π h·ª£p\", \"c√°ch ch·ªçn n∆∞·ªõc hoa\"
        - Th√¥ng tin s·∫£n ph·∫©m: gi√°, xu·∫•t x·ª©, ƒë·∫∑c ƒëi·ªÉm
        
        **QUAN TR·ªåNG - ƒê·ªäNH D·∫†NG S·∫¢N PH·∫®M:**
        - KH√îNG s·ª≠ d·ª•ng ### trong ti√™u ƒë·ªÅ s·∫£n ph·∫©m
        - S·ª≠ d·ª•ng **T√™n s·∫£n ph·∫©m** thay v√¨ ### T√™n s·∫£n ph·∫©m
        - KH√îNG s·ª≠ d·ª•ng ### 1. ### 2. ### 3. - ch·ªâ d√πng **1.** **2.** **3.**
        - N·∫øu c√≥ d·ªØ li·ªáu s·∫£n ph·∫©m trong product_data, H√ÉY S·ª¨ D·ª§NG CH√çNH X√ÅC
        - KH√îNG t·ª± t·∫°o danh s√°ch s·∫£n ph·∫©m - ch·ªâ s·ª≠ d·ª•ng d·ªØ li·ªáu c√≥ s·∫µn
        
        **PHONG C√ÅCH TR·∫¢ L·ªúI:**
        - Th√¢n thi·ªán, nhi·ªát t√¨nh, chuy√™n nghi·ªáp
        - S·ª≠ d·ª•ng emoji ph√π h·ª£p (üí¨üå∏‚ú®üõçÔ∏è)
        - ƒê∆∞a ra l·ªùi khuy√™n h·ªØu √≠ch v√† ch√≠nh x√°c
        - T·∫°o c·∫£m gi√°c tin c·∫≠y v√† g·∫ßn g≈©i
        - Format th√¥ng tin d·ªÖ ƒë·ªçc v·ªõi markdown
        - Lu√¥n d·ª±a tr√™n d·ªØ li·ªáu th·ª±c t·∫ø t·ª´ h·ªá th·ªëng";

        $reply = $this->llmService->chat($message, [
            'system' => $systemPrompt,
            'relevant_products' => $relevantProducts,
            'conversation_history' => $context['conversation_history'] ?? [],
            'real_data' => $this->dataService->formatBusinessContextForLLM($this->dataService->getBusinessContext()),
            'agent_data' => $chatData
        ]);
        
        // Remove ### from reply if present
        $reply = preg_replace('/###\s*\d+\.\s*/', '', $reply);
        $reply = str_replace('###', '', $reply); // Fallback

        return [
            'success' => true,
            'type' => 'llm',
            'reply' => $reply,
            'products' => [] // Ensure products key exists for frontend compatibility
        ];
    }

    /**
     * Get store context for LLM
     */
    private function getStoreContext(): string
    {
        try {
            $totalProducts = Product::count();
            $categories = \App\Models\Category::count();
            $avgPrice = Product::avg('price');
            
            return "C·ª≠a h√†ng c√≥ {$totalProducts} s·∫£n ph·∫©m n∆∞·ªõc hoa thu·ªôc {$categories} danh m·ª•c. Gi√° trung b√¨nh: " . number_format($avgPrice) . "ƒë";
        } catch (\Throwable $e) {
            return "C·ª≠a h√†ng n∆∞·ªõc hoa chuy√™n nghi·ªáp v·ªõi nhi·ªÅu s·∫£n ph·∫©m ch·∫•t l∆∞·ª£ng";
        }
    }

    /**
     * Check if message looks like product query
     */
    private function looksLikeProductQuery(string $message): bool
    {
        $productKeywords = ['n∆∞·ªõc hoa', 'perfume', 'm√πi h∆∞∆°ng', 'fragrance', 's·∫£n ph·∫©m', 'product'];
        
        foreach ($productKeywords as $keyword) {
            if (stripos($message, $keyword) !== false) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Format products for LLM context
     */
    private function formatProductsForLLM(array $products): string
    {
        $formatted = "Th√¥ng tin s·∫£n ph·∫©m li√™n quan:\n";
        
        foreach ($products as $product) {
            $name = $product['name'] ?? 'Unknown';
            $category = $product['category'] ?? 'N/A';
            $price = $product['price'] ?? 0;
            $description = $product['description'] ?? '';
            
            $formatted .= "- {$name} ({$category}): " . number_format($price) . "ƒë";
            if (!empty($description)) {
                $formatted .= " - {$description}";
            }
            $formatted .= "\n";
        }
        
        return $formatted;
    }

    /**
     * Handle text-based recommendation (fallback)
     */
    private function handleTextBasedRecommendation(string $message, array $context): array
    {
        $products = Product::where('name', 'LIKE', "%{$message}%")
            ->orWhere('description', 'LIKE', "%{$message}%")
            ->limit(5)
            ->get()
            ->map(function ($product) {
                return [
                    'id' => $product->id,
                    'name' => $product->name,
                    'price' => number_format($product->price),
                    'category' => $product->category->name ?? 'N/A',
                    'description' => $product->description ?? '',
                    'similarity' => 0
                ];
            })
            ->toArray();

        if (empty($products)) {
            return [
                'success' => true,
                'type' => 'product_recommendation',
                'products' => [],
                'reply' => 'T√¥i ch∆∞a th·ªÉ t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p. B·∫°n c√≥ th·ªÉ m√¥ t·∫£ c·ª• th·ªÉ h∆°n v·ªÅ s·ªü th√≠ch c·ªßa m√¨nh kh√¥ng?'
            ];
        }

        $productNames = array_column($products, 'name');
        $reply = "D·ª±a tr√™n y√™u c·∫ßu c·ªßa b·∫°n, t√¥i g·ª£i √Ω: " . implode(', ', $productNames);

        return [
            'success' => true,
            'type' => 'product_recommendation',
            'products' => $products,
            'reply' => $reply
        ];
    }

    /**
     * Handle text-based search (fallback)
     */
    private function handleTextBasedSearch(string $message, array $context): array
    {
        $products = Product::where('name', 'LIKE', "%{$message}%")
            ->orWhere('description', 'LIKE', "%{$message}%")
            ->limit(8)
            ->get()
            ->map(function ($product) {
                return [
                    'id' => $product->id,
                    'name' => $product->name,
                    'price' => number_format($product->price),
                    'category' => $product->category->name ?? 'N/A',
                    'description' => $product->description ?? '',
                    'similarity' => 0
                ];
            })
            ->toArray();

        if (empty($products)) {
            return [
                'success' => true,
                'type' => 'semantic_search',
                'products' => [],
                'reply' => 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o ph√π h·ª£p v·ªõi y√™u c·∫ßu c·ªßa b·∫°n.'
            ];
        }

        $productNames = array_column($products, 'name');
        $reply = "T√¨m th·∫•y " . count($products) . " s·∫£n ph·∫©m: " . implode(', ', $productNames);

        return [
            'success' => true,
            'type' => 'semantic_search',
            'products' => $products,
            'reply' => $reply
        ];
    }

    /**
     * Filter products by query from DataService
     */
    private function filterProductsByQuery(array $products, string $query): array
    {
        $queryLower = strtolower($query);
        $keywords = ['nam', 'n·ªØ', 'men', 'women', 'nam gi·ªõi', 'n·ªØ gi·ªõi', 'unisex'];
        
        $filtered = [];
        foreach ($products as $product) {
            $productText = strtolower($product['name'] . ' ' . $product['brand'] . ' ' . ($product['description'] ?? ''));
            
            // Check if query matches product
            if (strpos($productText, $queryLower) !== false) {
                $filtered[] = $product;
            } else {
                // Check for gender keywords
                foreach ($keywords as $keyword) {
                    if (strpos($queryLower, $keyword) !== false && strpos($productText, $keyword) !== false) {
                        $filtered[] = $product;
                        break;
                    }
                }
            }
        }
        
        return array_slice($filtered, 0, 5); // Limit to 5 products
    }

    /**
     * Format products from DataService for LLM
     */
    private function formatProductsFromDataService(array $products): string
    {
        if (empty($products)) {
            return '';
        }

        $formatted = "üõçÔ∏è **S·∫¢N PH·∫®M LI√äN QUAN:**\n\n";
        
        foreach ($products as $i => $product) {
            $formatted .= "**" . ((int)$i + 1) . ". " . $product['name'] . "**\n";
            $formatted .= "‚Ä¢ **Th∆∞∆°ng hi·ªáu:** " . ($product['brand'] ?? 'N/A') . "\n";
            $formatted .= "‚Ä¢ **Gi√°:** " . number_format((float)($product['price'] ?? 0)) . "ƒë\n";
            $formatted .= "‚Ä¢ **T·ªìn kho:** " . ($product['stock'] ?? 0) . " s·∫£n ph·∫©m\n";
            $formatted .= "‚Ä¢ **Danh m·ª•c:** " . ($product['category'] ?? 'N/A') . "\n";
            
            if (!empty($product['description'])) {
                $formatted .= "‚Ä¢ **M√¥ t·∫£:** " . substr($product['description'], 0, 100) . "...\n";
            }
            
            $formatted .= "\n";
        }

        return $formatted;
    }
}
